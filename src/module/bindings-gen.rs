/* automatically generated by rust-bindgen 0.63.0 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn init(handler: *mut *mut ::std::os::raw::c_void);
}
pub const ConnParamType_ConnParamBool: ConnParamType = 0;
pub const ConnParamType_ConnParamInt: ConnParamType = 1;
pub const ConnParamType_ConnParamFloat: ConnParamType = 2;
pub const ConnParamType_ConnParamString: ConnParamType = 3;
pub type ConnParamType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConnParamConf {
    pub name: *mut ::std::os::raw::c_char,
    pub typ: ConnParamType,
}
#[test]
fn bindgen_test_layout_ConnParamConf() {
    const UNINIT: ::std::mem::MaybeUninit<ConnParamConf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ConnParamConf>(),
        16usize,
        concat!("Size of: ", stringify!(ConnParamConf))
    );
    assert_eq!(
        ::std::mem::align_of::<ConnParamConf>(),
        8usize,
        concat!("Alignment of ", stringify!(ConnParamConf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConnParamConf),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typ) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConnParamConf),
            "::",
            stringify!(typ)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceInfo {
    pub connection_params: *mut ConnParamConf,
    pub connection_params_len: i32,
}
#[test]
fn bindgen_test_layout_DeviceInfo() {
    const UNINIT: ::std::mem::MaybeUninit<DeviceInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DeviceInfo>(),
        16usize,
        concat!("Size of: ", stringify!(DeviceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<DeviceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(DeviceInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceInfo),
            "::",
            stringify!(connection_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_params_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceInfo),
            "::",
            stringify!(connection_params_len)
        )
    );
}
pub type device_info_callback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut DeviceInfo),
>;
extern "C" {
    pub fn obtain_device_info(
        handler: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        callback: device_info_callback,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConnParam {
    pub name: *mut ::std::os::raw::c_char,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ConnParam() {
    const UNINIT: ::std::mem::MaybeUninit<ConnParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ConnParam>(),
        16usize,
        concat!("Size of: ", stringify!(ConnParam))
    );
    assert_eq!(
        ::std::mem::align_of::<ConnParam>(),
        8usize,
        concat!("Alignment of ", stringify!(ConnParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ConnParam),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ConnParam),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceConnectInfo {
    pub connection_params: *mut ConnParam,
    pub connection_params_len: i32,
}
#[test]
fn bindgen_test_layout_DeviceConnectInfo() {
    const UNINIT: ::std::mem::MaybeUninit<DeviceConnectInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DeviceConnectInfo>(),
        16usize,
        concat!("Size of: ", stringify!(DeviceConnectInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<DeviceConnectInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(DeviceConnectInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceConnectInfo),
            "::",
            stringify!(connection_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connection_params_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceConnectInfo),
            "::",
            stringify!(connection_params_len)
        )
    );
}
extern "C" {
    pub fn connect_device(
        handler: *mut ::std::os::raw::c_void,
        connect_info: *mut DeviceConnectInfo,
    ) -> i8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RecordInterval {
    pub min: i32,
    pub max: i32,
    pub def: i32,
}
#[test]
fn bindgen_test_layout_RecordInterval() {
    const UNINIT: ::std::mem::MaybeUninit<RecordInterval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RecordInterval>(),
        12usize,
        concat!("Size of: ", stringify!(RecordInterval))
    );
    assert_eq!(
        ::std::mem::align_of::<RecordInterval>(),
        4usize,
        concat!("Alignment of ", stringify!(RecordInterval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordInterval),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordInterval),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).def) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RecordInterval),
            "::",
            stringify!(def)
        )
    );
}
pub const SensorDataType_SensorDataInt: SensorDataType = 0;
pub const SensorDataType_SensorDataFloat: SensorDataType = 1;
pub type SensorDataType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SensorData {
    pub typ: SensorDataType,
    pub definition: *mut ::std::os::raw::c_char,
    pub min: *mut ::std::os::raw::c_char,
    pub max: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SensorData() {
    const UNINIT: ::std::mem::MaybeUninit<SensorData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SensorData>(),
        32usize,
        concat!("Size of: ", stringify!(SensorData))
    );
    assert_eq!(
        ::std::mem::align_of::<SensorData>(),
        8usize,
        concat!("Alignment of ", stringify!(SensorData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorData),
            "::",
            stringify!(typ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).definition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorData),
            "::",
            stringify!(definition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorData),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorData),
            "::",
            stringify!(max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SensorInfo {
    pub intern_name: *mut ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
    pub record_interval: RecordInterval,
    pub data: SensorData,
}
#[test]
fn bindgen_test_layout_SensorInfo() {
    const UNINIT: ::std::mem::MaybeUninit<SensorInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SensorInfo>(),
        64usize,
        concat!("Size of: ", stringify!(SensorInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SensorInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SensorInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intern_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorInfo),
            "::",
            stringify!(intern_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_interval) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorInfo),
            "::",
            stringify!(record_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorInfo),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SensorInfos {
    pub sensor_infos: *mut SensorInfo,
    pub sensor_infos_len: i32,
}
#[test]
fn bindgen_test_layout_SensorInfos() {
    const UNINIT: ::std::mem::MaybeUninit<SensorInfos> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SensorInfos>(),
        16usize,
        concat!("Size of: ", stringify!(SensorInfos))
    );
    assert_eq!(
        ::std::mem::align_of::<SensorInfos>(),
        8usize,
        concat!("Alignment of ", stringify!(SensorInfos))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor_infos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorInfos),
            "::",
            stringify!(sensor_infos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor_infos_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorInfos),
            "::",
            stringify!(sensor_infos_len)
        )
    );
}
pub type sensor_infos_callback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut SensorInfos),
>;
extern "C" {
    pub fn obtain_sensor_infos(
        handler: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        callback: sensor_infos_callback,
    ) -> i8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SensorTolerance {
    pub min: *mut ::std::os::raw::c_char,
    pub max: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SensorTolerance() {
    const UNINIT: ::std::mem::MaybeUninit<SensorTolerance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SensorTolerance>(),
        16usize,
        concat!("Size of: ", stringify!(SensorTolerance))
    );
    assert_eq!(
        ::std::mem::align_of::<SensorTolerance>(),
        8usize,
        concat!("Alignment of ", stringify!(SensorTolerance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorTolerance),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorTolerance),
            "::",
            stringify!(max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SensorConf {
    pub enable: bool,
    pub record_interval: i32,
    pub tolerance: SensorTolerance,
}
#[test]
fn bindgen_test_layout_SensorConf() {
    const UNINIT: ::std::mem::MaybeUninit<SensorConf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SensorConf>(),
        24usize,
        concat!("Size of: ", stringify!(SensorConf))
    );
    assert_eq!(
        ::std::mem::align_of::<SensorConf>(),
        8usize,
        concat!("Alignment of ", stringify!(SensorConf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorConf),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record_interval) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorConf),
            "::",
            stringify!(record_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tolerance) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SensorConf),
            "::",
            stringify!(tolerance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceConf {
    pub sensor_confs: *mut SensorConf,
    pub sensor_confs_len: i32,
}
#[test]
fn bindgen_test_layout_DeviceConf() {
    const UNINIT: ::std::mem::MaybeUninit<DeviceConf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DeviceConf>(),
        16usize,
        concat!("Size of: ", stringify!(DeviceConf))
    );
    assert_eq!(
        ::std::mem::align_of::<DeviceConf>(),
        8usize,
        concat!("Alignment of ", stringify!(DeviceConf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor_confs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceConf),
            "::",
            stringify!(sensor_confs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensor_confs_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceConf),
            "::",
            stringify!(sensor_confs_len)
        )
    );
}
extern "C" {
    pub fn configure(
        handler: *mut ::std::os::raw::c_void,
        device_conf: *mut DeviceConf,
        data_dir: *mut ::std::os::raw::c_char,
    ) -> i8;
}
